#include <locale.h>
#include <iostream>

/* Факториал числа Х - это произведение всех натуральных чисел от 1 до Х включительно.
Х! = 1 * 2 * 3 * ... * Х
Факториал существует только для целочисленных положительных чисел.
0! = 1; 1! = 1; факториал отрицательного числа не существует. */

using namespace std;

int main()
{
    setlocale(LC_ALL, "rus");
    cout << "---------------------------------------------Программа для вычисления факториала числа!----------------------------------------------------------" << endl;

    /*  F = n! = n * (n - 1)! или же 5! = 5 * 4!    =    5 * 4 * 3!    =    5 * 4 * 3 * 2!    =    5 * 4 * 3 * 2 * 1!    =    5 * 4 * 3 * 2 * 1 = 120
        В цикле мы будем брать числа от 1 до заданного и перемножать. */

    int n = 0;
    int i = 1;                                                          // счетчик, перебирает числа от 1 до n
    double F = 1.0;                                                     // для хранения результата (большого числа в экспаненциальной форме)
    //unsigned long long F = 1;                                         // результат, заменен на double, т.к. не позволяет хранить большие числа (факториал 21 и больше)

    cout << "Введите число n, не больше 170: "; cin >> n;

    if (n > 170)
        cout << "Используйте другую программу!" << endl;
    else
    {
        if (n < 0)
            cout << "Факториал не существует!" << endl;
        else
        {
            if (!n)
                cout << "Факториал = 1" << endl;                       // универсальная запись выражения для проверки на равенство нулю. Что и if(n==0), но эта запись
            // неудобна из-за разных типов данных. Т.к. у нас int, то все ок, но если бы был double например,
            // то писать пришлось бы if(n==0.0) для избежания преобразования типов данных для сравнения
            // эту проверку можно делать как на равенство нулю if(!n), так и на отличие от нуля if(n)
            else
            {
                while (i <= n)                                         // пока счетчик i меньше или равен введенному числу
                {
                    F *= i;                                            // F=F*i; мы берем i и на неe домножаем результат (пример внизу под звездочкой)
                    i++;
                    cout << F << endl;                                 // вывод на экран промежуточных значений
                }
                cout << "Факториал равен " << F << endl;               // итоговый результат8
            }
        }
    }
}

/* !n - это логическая инверсия, т.е. обращает истину в ложь и наоборот (у if, и у циклов в скобочках стоят выражения логических типов данных).

Если мы говорим об одиночном объекте (не результате логического выражения), то ложью является ноль, а все остальное истина. Если n = 0, то только тогда это будет ложь,
со всеми другими полож. и отриц.числами это будет истина. Но в нашем случае берется инверсия, т.е. истиной она будет когда равна нулю, а ложью, когда неравна нулю.
If сработает когда будет истина, а именнo в данном случае когда n = 0. Т.е. например, n равна 1, в скобках if она перевоплотится в истину, потом сработает инверсия и
перевоплотит истину с ложь, if ложь проигнорирует и число, не равное нулю, попадет в else.

(!) последовательность из ноликов так же является ложью, не только один ноль.

Данное логическое сравнение лучше, т.к. мы не привязаны к конкретному типу данных, поскольку в int это 0, в double это 0.0, в float это 0.0F. А при логическом
сравнении тип данных значения не имеет и мы избегаем неявного преобразования. Для равенства нулю (!n) или отличие от нуля (n) эти действия отлично подходят.

(*)     Предыдущий результат         Счетчик
                 1             *        1         =         1
                 1             *        2         =         2
                 2             *        3         =         6
                 6             *        4         =        24
                24             *        5         =        120
Мы в цикле берем и заново F домножаем на i и результат помещаем в F. Мы заданное количество раз умножаем F на счетчик, перебирающий все цифры от 1 до n.

Если мы попросим вычислить факториал 21 и больше, мы получим неверный результат, т.к. у нас кончатся разряды на факториале 21 и больше. Нам не хватает места. Т.е. даже
unsigned long long не может вместить в себя факториал 21. Чтобы выйти из этой ситуации существуют большие типы данных, например big int, big...
Здесь же мы воспользуемся след.логикой, в математике очень длинные числа записываются экспоненциально, например (5*10^13). Вещественные числа всегда хранятся в экспонен.
форме, след, могут поместить в себя большое число. Вещественный тип данных позволяет хранить в себе очень большие числа, а именно (float, double, long double). Т.е.
вместо unsigned long long мы применим double - переменную для хранения большого результата в эксп.форме.

(!) тип данных float и double могут содержать в себе только 6 цифер и эти 6 цифер распределяются между целой и дробной частью. Если в целой части больше 6 цифер, то бу-
дет преобразование в экспон.форму: одна цифра будет лишь в целой части, далее точка, а остальные цифры запишутся в дробной части, умноженные на степень, соответствующую
изначальному числу. Так записываются целые числа, но только большие!

Но и вещественный тип данных не бесконечный. Он работает лишь максимус с факториалом 170. При вычислении факториала 171 и больше мы уходим в бесконечность. След, для
более больших вычислений уже требуется тот самый "большой тип данных big..".
Факториал 170 равен 7.25742е^306 - гигантское число! А именно е^306 показывает что, убрав точку, к 2-ке к числу добавятся еще 301 символ - число длинною 307 символов. */